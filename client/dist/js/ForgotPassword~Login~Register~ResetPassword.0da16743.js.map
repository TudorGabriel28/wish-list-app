{"version":3,"sources":["webpack:///./src/utils/validations.js","webpack:///./node_modules/vee-validate/dist/vee-validate.esm.js"],"names":["nameValidation","value","regex","test","emailValidation","String","toLowerCase","passwordValidation","isCallable","fn","isNullOrUndefined","undefined","isObject","obj","Array","isArray","isIndex","Number","toNumber","n","parseFloat","isNaN","RULES","resolveRule","id","FormContextKey","Symbol","FormErrorsKey","FormInitialValuesKey","FieldContextKey","IS_ABSENT","isLocator","__locatorRef","isHTMLTag","tag","includes","isFileInputNode","attrs","type","isYupValidator","validate","hasCheckedAttr","isContainerValue","isEmptyContainer","length","Object","keys","isNotNestedPath","path","isNativeMultiSelect","el","tagName","multiple","isNativeMultiSelectNode","hasTruthyBindingValue","shouldHaveValueBinding","isFormSubmitEvent","evt","isEvent","target","Event","srcElement","isPropPresent","prop","cleanupNonNestedPath","replace","getFromPath","object","fallback","resolvedValue","split","filter","Boolean","reduce","acc","propKey","setInPath","i","unset","key","splice","unsetPath","pathValues","map","_","idx","slice","join","keysOf","record","injectWithSelf","symbol","def","vm","provides","normalizeField","field","applyFieldMutation","mutation","onlyFirst","forEach","resolveNextCheckboxValue","currentValue","checkedValue","uncheckedValue","newVal","indexOf","push","normalizeChildren","context","slotProps","slots","default","_a","_b","call","getBoundValue","hasValueBinding","_value","normalizeEventValue","input","files","from","options","opt","selected","disabled","normalizeRules","rules","defineProperty","writable","enumerable","configurable","_$$isNormalized","prev","curr","params","normalizeParams","buildParams","rule","parsedRule","parseRule","name","provided","mapValueToLocator","createLocator","RegExp","locator","crossTable","val","extractLocators","DEFAULT_CONFIG","generateMessage","bails","validateOnBlur","validateOnChange","validateOnInput","validateOnModelUpdate","currentConfig","assign","getConfig","async","shouldBail","formData","values","result","_validate","errors","valid","validateFieldWithYup","ctx","form","isValid","message","_generateFieldError","normalizedContext","rulesKeys","_test","error","validator","opts","abortEarly","then","catch","err","Error","fillTargetValues","fieldCtx","normalize","param","validateYupSchema","schema","errorObjects","inner","results","messages","validateObjectSchema","paths","validations","_c","fieldResult","names","bailsMap","isAllValid","validationResults","Promise","all","klona","x","k","tmp","str","prototype","toString","constructor","hasOwnProperty","Date","source","flags","lastIndex","es6","equal","a","b","Map","size","entries","has","get","Set","ArrayBuffer","isView","valueOf","ID_COUNTER","useField","fid","MAX_SAFE_INTEGER","initialValue","validateOnMount","label","validateOnValueUpdate","standalone","normalizeOptions","meta","errorMessage","handleBlur","handleInput","resetValidationState","setValidationState","setErrors","checked","useValidationState","initValue","normalizedRules","rulesValue","extractRuleFromSchema","validateCurrentValue","mode","validateSchema","validateWithStateMutation","pending","validated","validateValidStateOnly","handleChange","e","shouldValidate","newValue","setTouched","isTouched","touched","unwatchValue","watchValue","deep","resetField","state","handleReset","oldValue","register","unregister","dependencies","rulesVal","deps","dep","depAcc","depName","depValue","oldDeps","dirty","defaults","valueProp","useFieldErrors","formInitialValues","initialValueRef","useFieldValue$1","useFieldMeta","fieldPath","setFieldValue","force","setFieldInitialValue","immediate","flush","fieldName","stageInitialValue","errorBag","setFieldErrorBag","inheritAttrs","props","as","required","Function","modelValue","modelModifiers","hasModelEvents","validateField","resolveInitialValue","onChangeHandler","emit","onInputHandler","fieldProps","resolveValidationTriggers","baseOnBlur","onBlur","baseOnInput","onInput","baseOnChange","onChange","resolveTag","newModelValue","applyModifiers","children","_d","modifiers","number","useForm","fields","isSubmitting","fieldsById","existingField","fieldGroup","submitCount","formValues","initialValues","valuesByFid","setErrorBag","useErrorBag","initialErrors","bag","fieldNames","fieldBailsMap","readonlyInitialValues","setInitialValues","useFormInitialValues","useFormMeta","validationSchema","formCtx","registerField","unregisterField","setValues","setFieldError","setFieldTouched","resetForm","handleSubmit","fieldInstance","clonedValue","fieldItem","f","newPath","oldPath","isSharingName","find","initialErrorMessage","valueIdx","validation","every","r","resolve","preventDefault","stopPropagation","schemaValue","formResult","currentErrorsPaths","wasValidated","some","submitForm","submit","initialTouched","currentValues","MERGE_STRATEGIES","isDirty","flag","mergeMethod","providedValues","computedInitials","updateFields","hadInteraction","touchedByUser","normalizeErrorItem","onSubmit","handleFormReset","onReset","handleScopedSlotSubmit","onSuccess","expose","formAttrs","novalidate","role"],"mappings":"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","file":"js/ForgotPassword~Login~Register~ResetPassword.0da16743.js","sourcesContent":["function nameValidation(value) {\r\n  const regex = /^\\s/;\r\n  if (!value || regex.test(value)) {\r\n    return 'This is required';\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction emailValidation(value) {\r\n  if (!value) {\r\n    return 'This is required';\r\n  }\r\n\r\n  const regex =\r\n    /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n\r\n  if (!regex.test(String(value).toLowerCase())) {\r\n    return 'Please enter a valid email address';\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction passwordValidation(value) {\r\n  if (!value) {\r\n    return 'This is required';\r\n  }\r\n\r\n  const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d\\w\\W]{8,}$/;\r\n\r\n  if (!regex.test(value)) {\r\n    return 'Minimum 8 characters, one uppercase, one lowercase letter and one number';\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction titleValidation(value) {\r\n  const regex = /^\\s/;\r\n  if (!value || regex.test(value)) {\r\n    return 'This is required';\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction notEmptyValidation(value) {\r\n  if (!value || value == '') {\r\n    return 'This is required';\r\n  }\r\n  return true;\r\n}\r\n\r\nexport {\r\n  nameValidation,\r\n  emailValidation,\r\n  passwordValidation,\r\n  titleValidation,\r\n  notEmptyValidation\r\n};\r\n","/**\n  * vee-validate v4.4.9\n  * (c) 2021 Abdelrahman Awad\n  * @license MIT\n  */\nimport { inject, getCurrentInstance, warn as warn$1, unref, computed, onMounted, provide, isRef, watch, onBeforeUnmount, ref, reactive, nextTick, defineComponent, toRef, resolveDynamicComponent, h } from 'vue';\n\nfunction isCallable(fn) {\r\n    return typeof fn === 'function';\r\n}\r\nfunction isNullOrUndefined(value) {\r\n    return value === null || value === undefined;\r\n}\r\nconst isObject = (obj) => obj !== null && !!obj && typeof obj === 'object' && !Array.isArray(obj);\r\nfunction isIndex(value) {\r\n    return Number(value) >= 0;\r\n}\r\nfunction toNumber(value) {\r\n    const n = parseFloat(value);\r\n    return isNaN(n) ? value : n;\r\n}\n\nconst RULES = {};\r\n/**\r\n * Adds a custom validator to the list of validation rules.\r\n */\r\nfunction defineRule(id, validator) {\r\n    // makes sure new rules are properly formatted.\r\n    guardExtend(id, validator);\r\n    RULES[id] = validator;\r\n}\r\n/**\r\n * Gets an already defined rule\r\n */\r\nfunction resolveRule(id) {\r\n    return RULES[id];\r\n}\r\n/**\r\n * Guards from extension violations.\r\n */\r\nfunction guardExtend(id, validator) {\r\n    if (isCallable(validator)) {\r\n        return;\r\n    }\r\n    throw new Error(`Extension Error: The validator '${id}' must be a function.`);\r\n}\n\nconst FormContextKey = Symbol('vee-validate-form');\r\nconst FormErrorsKey = Symbol('vee-validate-form-errors');\r\nconst FormInitialValuesKey = Symbol('vee-validate-form-initial-values');\r\nconst FieldContextKey = Symbol('vee-validate-field-instance');\r\nconst IS_ABSENT = Symbol('Default empty value');\n\nfunction isLocator(value) {\r\n    return isCallable(value) && !!value.__locatorRef;\r\n}\r\n/**\r\n * Checks if an tag name is a native HTML tag and not a Vue component\r\n */\r\nfunction isHTMLTag(tag) {\r\n    return ['input', 'textarea', 'select'].includes(tag);\r\n}\r\n/**\r\n * Checks if an input is of type file\r\n */\r\nfunction isFileInputNode(tag, attrs) {\r\n    return isHTMLTag(tag) && attrs.type === 'file';\r\n}\r\nfunction isYupValidator(value) {\r\n    return !!value && isCallable(value.validate);\r\n}\r\nfunction hasCheckedAttr(type) {\r\n    return type === 'checkbox' || type === 'radio';\r\n}\r\nfunction isContainerValue(value) {\r\n    return isObject(value) || Array.isArray(value);\r\n}\r\n/**\r\n * True if the value is an empty object or array\r\n */\r\nfunction isEmptyContainer(value) {\r\n    if (Array.isArray(value)) {\r\n        return value.length === 0;\r\n    }\r\n    return isObject(value) && Object.keys(value).length === 0;\r\n}\r\n/**\r\n * Checks if the path opted out of nested fields using `[fieldName]` syntax\r\n */\r\nfunction isNotNestedPath(path) {\r\n    return /^\\[.+\\]$/i.test(path);\r\n}\r\n/**\r\n * Checks if an element is a native HTML5 multi-select input element\r\n */\r\nfunction isNativeMultiSelect(el) {\r\n    return el.tagName === 'SELECT' && el.multiple;\r\n}\r\n/**\r\n * Checks if a tag name with attrs object will render a native multi-select element\r\n */\r\nfunction isNativeMultiSelectNode(tag, attrs) {\r\n    // The falsy value array is the values that Vue won't add the `multiple` prop if it has one of these values\r\n    const hasTruthyBindingValue = ![false, null, undefined, 0].includes(attrs.multiple) && !Number.isNaN(attrs.multiple);\r\n    return tag === 'select' && 'multiple' in attrs && hasTruthyBindingValue;\r\n}\r\n/**\r\n * Checks if a node should have a `:value` binding or not\r\n *\r\n * These nodes should not have a value binding\r\n * For files, because they are not reactive\r\n * For multi-selects because the value binding will reset the value\r\n */\r\nfunction shouldHaveValueBinding(tag, attrs) {\r\n    return isNativeMultiSelectNode(tag, attrs) || isFileInputNode(tag, attrs);\r\n}\r\nfunction isFormSubmitEvent(evt) {\r\n    return isEvent(evt) && evt.target && 'submit' in evt.target;\r\n}\r\nfunction isEvent(evt) {\r\n    if (!evt) {\r\n        return false;\r\n    }\r\n    if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {\r\n        return true;\r\n    }\r\n    // this is for IE and Cypress #3161\r\n    /* istanbul ignore next */\r\n    if (evt && evt.srcElement) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction isPropPresent(obj, prop) {\r\n    return prop in obj && obj[prop] !== IS_ABSENT;\r\n}\n\nfunction cleanupNonNestedPath(path) {\r\n    if (isNotNestedPath(path)) {\r\n        return path.replace(/\\[|\\]/gi, '');\r\n    }\r\n    return path;\r\n}\r\n/**\r\n * Gets a nested property value from an object\r\n */\r\nfunction getFromPath(object, path, fallback = undefined) {\r\n    if (!object) {\r\n        return fallback;\r\n    }\r\n    if (isNotNestedPath(path)) {\r\n        return object[cleanupNonNestedPath(path)];\r\n    }\r\n    const resolvedValue = path\r\n        .split(/\\.|\\[(\\d+)\\]/)\r\n        .filter(Boolean)\r\n        .reduce((acc, propKey) => {\r\n        if (isContainerValue(acc) && propKey in acc) {\r\n            return acc[propKey];\r\n        }\r\n        return fallback;\r\n    }, object);\r\n    return resolvedValue;\r\n}\r\n/**\r\n * Sets a nested property value in a path, creates the path properties if it doesn't exist\r\n */\r\nfunction setInPath(object, path, value) {\r\n    if (isNotNestedPath(path)) {\r\n        object[cleanupNonNestedPath(path)] = value;\r\n        return;\r\n    }\r\n    const keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\r\n    let acc = object;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        // Last key, set it\r\n        if (i === keys.length - 1) {\r\n            acc[keys[i]] = value;\r\n            return;\r\n        }\r\n        // Key does not exist, create a container for it\r\n        if (!(keys[i] in acc) || isNullOrUndefined(acc[keys[i]])) {\r\n            // container can be either an object or an array depending on the next key if it exists\r\n            acc[keys[i]] = isIndex(keys[i + 1]) ? [] : {};\r\n        }\r\n        acc = acc[keys[i]];\r\n    }\r\n}\r\nfunction unset(object, key) {\r\n    if (Array.isArray(object) && isIndex(key)) {\r\n        object.splice(Number(key), 1);\r\n        return;\r\n    }\r\n    if (isObject(object)) {\r\n        delete object[key];\r\n    }\r\n}\r\n/**\r\n * Removes a nested property from object\r\n */\r\nfunction unsetPath(object, path) {\r\n    if (isNotNestedPath(path)) {\r\n        delete object[cleanupNonNestedPath(path)];\r\n        return;\r\n    }\r\n    const keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\r\n    let acc = object;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        // Last key, unset it\r\n        if (i === keys.length - 1) {\r\n            unset(acc, keys[i]);\r\n            break;\r\n        }\r\n        // Key does not exist, exit\r\n        if (!(keys[i] in acc) || isNullOrUndefined(acc[keys[i]])) {\r\n            break;\r\n        }\r\n        acc = acc[keys[i]];\r\n    }\r\n    const pathValues = keys.map((_, idx) => {\r\n        return getFromPath(object, keys.slice(0, idx).join('.'));\r\n    });\r\n    for (let i = pathValues.length - 1; i >= 0; i--) {\r\n        if (!isEmptyContainer(pathValues[i])) {\r\n            continue;\r\n        }\r\n        if (i === 0) {\r\n            unset(object, keys[0]);\r\n            continue;\r\n        }\r\n        unset(pathValues[i - 1], keys[i - 1]);\r\n    }\r\n}\r\n/**\r\n * A typed version of Object.keys\r\n */\r\nfunction keysOf(record) {\r\n    return Object.keys(record);\r\n}\r\n// Uses same component provide as its own injections\r\n// Due to changes in https://github.com/vuejs/vue-next/pull/2424\r\nfunction injectWithSelf(symbol, def = undefined) {\r\n    const vm = getCurrentInstance();\r\n    return (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || inject(symbol, def);\r\n}\r\nfunction warn(message) {\r\n    warn$1(`[vee-validate]: ${message}`);\r\n}\r\n/**\r\n * Ensures we deal with a singular field value\r\n */\r\nfunction normalizeField(field) {\r\n    if (Array.isArray(field)) {\r\n        return field[0];\r\n    }\r\n    return field;\r\n}\r\n/**\r\n * Applies a mutation function on a field or field group\r\n */\r\nfunction applyFieldMutation(field, mutation, onlyFirst = false) {\r\n    if (!Array.isArray(field)) {\r\n        mutation(field);\r\n        return;\r\n    }\r\n    if (onlyFirst) {\r\n        mutation(field[0]);\r\n        return;\r\n    }\r\n    field.forEach(mutation);\r\n}\r\nfunction resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {\r\n    if (Array.isArray(currentValue)) {\r\n        const newVal = [...currentValue];\r\n        const idx = newVal.indexOf(checkedValue);\r\n        idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);\r\n        return newVal;\r\n    }\r\n    return currentValue === checkedValue ? uncheckedValue : checkedValue;\r\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst normalizeChildren = (tag, context, slotProps) => {\r\n    if (!context.slots.default) {\r\n        return context.slots.default;\r\n    }\r\n    if (typeof tag === 'string' || !tag) {\r\n        return context.slots.default(slotProps());\r\n    }\r\n    return {\r\n        default: () => { var _a, _b; return (_b = (_a = context.slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, slotProps()); },\r\n    };\r\n};\r\n/**\r\n * Vue adds a `_value` prop at the moment on the input elements to store the REAL value on them, real values are different than the `value` attribute\r\n * as they do not get casted to strings unlike `el.value` which preserves user-code behavior\r\n */\r\nfunction getBoundValue(el) {\r\n    if (hasValueBinding(el)) {\r\n        return el._value;\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Vue adds a `_value` prop at the moment on the input elements to store the REAL value on them, real values are different than the `value` attribute\r\n * as they do not get casted to strings unlike `el.value` which preserves user-code behavior\r\n */\r\nfunction hasValueBinding(el) {\r\n    return '_value' in el;\r\n}\n\nfunction normalizeEventValue(value) {\r\n    if (!isEvent(value)) {\r\n        return value;\r\n    }\r\n    const input = value.target;\r\n    // Vue sets the current bound value on `_value` prop\r\n    // for checkboxes it it should fetch the value binding type as is (boolean instead of string)\r\n    if (hasCheckedAttr(input.type) && hasValueBinding(input)) {\r\n        return getBoundValue(input);\r\n    }\r\n    if (input.type === 'file' && input.files) {\r\n        return Array.from(input.files);\r\n    }\r\n    if (isNativeMultiSelect(input)) {\r\n        return Array.from(input.options)\r\n            .filter(opt => opt.selected && !opt.disabled)\r\n            .map(getBoundValue);\r\n    }\r\n    return input.value;\r\n}\n\n/**\r\n * Normalizes the given rules expression.\r\n */\r\nfunction normalizeRules(rules) {\r\n    const acc = {};\r\n    Object.defineProperty(acc, '_$$isNormalized', {\r\n        value: true,\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false,\r\n    });\r\n    if (!rules) {\r\n        return acc;\r\n    }\r\n    // Object is already normalized, skip.\r\n    if (isObject(rules) && rules._$$isNormalized) {\r\n        return rules;\r\n    }\r\n    if (isObject(rules)) {\r\n        return Object.keys(rules).reduce((prev, curr) => {\r\n            const params = normalizeParams(rules[curr]);\r\n            if (rules[curr] !== false) {\r\n                prev[curr] = buildParams(params);\r\n            }\r\n            return prev;\r\n        }, acc);\r\n    }\r\n    /* istanbul ignore if */\r\n    if (typeof rules !== 'string') {\r\n        return acc;\r\n    }\r\n    return rules.split('|').reduce((prev, rule) => {\r\n        const parsedRule = parseRule(rule);\r\n        if (!parsedRule.name) {\r\n            return prev;\r\n        }\r\n        prev[parsedRule.name] = buildParams(parsedRule.params);\r\n        return prev;\r\n    }, acc);\r\n}\r\n/**\r\n * Normalizes a rule param.\r\n */\r\nfunction normalizeParams(params) {\r\n    if (params === true) {\r\n        return [];\r\n    }\r\n    if (Array.isArray(params)) {\r\n        return params;\r\n    }\r\n    if (isObject(params)) {\r\n        return params;\r\n    }\r\n    return [params];\r\n}\r\nfunction buildParams(provided) {\r\n    const mapValueToLocator = (value) => {\r\n        // A target param using interpolation\r\n        if (typeof value === 'string' && value[0] === '@') {\r\n            return createLocator(value.slice(1));\r\n        }\r\n        return value;\r\n    };\r\n    if (Array.isArray(provided)) {\r\n        return provided.map(mapValueToLocator);\r\n    }\r\n    // #3073\r\n    if (provided instanceof RegExp) {\r\n        return [provided];\r\n    }\r\n    return Object.keys(provided).reduce((prev, key) => {\r\n        prev[key] = mapValueToLocator(provided[key]);\r\n        return prev;\r\n    }, {});\r\n}\r\n/**\r\n * Parses a rule string expression.\r\n */\r\nconst parseRule = (rule) => {\r\n    let params = [];\r\n    const name = rule.split(':')[0];\r\n    if (rule.includes(':')) {\r\n        params = rule.split(':').slice(1).join(':').split(',');\r\n    }\r\n    return { name, params };\r\n};\r\nfunction createLocator(value) {\r\n    const locator = (crossTable) => {\r\n        const val = getFromPath(crossTable, value) || crossTable[value];\r\n        return val;\r\n    };\r\n    locator.__locatorRef = value;\r\n    return locator;\r\n}\r\nfunction extractLocators(params) {\r\n    if (Array.isArray(params)) {\r\n        return params.filter(isLocator);\r\n    }\r\n    return keysOf(params)\r\n        .filter(key => isLocator(params[key]))\r\n        .map(key => params[key]);\r\n}\n\nconst DEFAULT_CONFIG = {\r\n    generateMessage: ({ field }) => `${field} is not valid.`,\r\n    bails: true,\r\n    validateOnBlur: true,\r\n    validateOnChange: true,\r\n    validateOnInput: false,\r\n    validateOnModelUpdate: true,\r\n};\r\nlet currentConfig = Object.assign({}, DEFAULT_CONFIG);\r\nconst getConfig = () => currentConfig;\r\nconst setConfig = (newConf) => {\r\n    currentConfig = Object.assign(Object.assign({}, currentConfig), newConf);\r\n};\r\nconst configure = setConfig;\n\n/**\r\n * Validates a value against the rules.\r\n */\r\nasync function validate(value, rules, options = {}) {\r\n    const shouldBail = options === null || options === void 0 ? void 0 : options.bails;\r\n    const field = {\r\n        name: (options === null || options === void 0 ? void 0 : options.name) || '{field}',\r\n        rules,\r\n        bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,\r\n        formData: (options === null || options === void 0 ? void 0 : options.values) || {},\r\n    };\r\n    const result = await _validate(field, value);\r\n    const errors = result.errors;\r\n    return {\r\n        errors,\r\n        valid: !errors.length,\r\n    };\r\n}\r\n/**\r\n * Starts the validation process.\r\n */\r\nasync function _validate(field, value) {\r\n    if (isYupValidator(field.rules)) {\r\n        return validateFieldWithYup(value, field.rules, { bails: field.bails });\r\n    }\r\n    // if a generic function, use it as the pipeline.\r\n    if (isCallable(field.rules)) {\r\n        const ctx = {\r\n            field: field.name,\r\n            form: field.formData,\r\n            value: value,\r\n        };\r\n        const result = await field.rules(value, ctx);\r\n        const isValid = typeof result !== 'string' && result;\r\n        const message = typeof result === 'string' ? result : _generateFieldError(ctx);\r\n        return {\r\n            errors: !isValid ? [message] : [],\r\n        };\r\n    }\r\n    const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(field.rules) });\r\n    const errors = [];\r\n    const rulesKeys = Object.keys(normalizedContext.rules);\r\n    const length = rulesKeys.length;\r\n    for (let i = 0; i < length; i++) {\r\n        const rule = rulesKeys[i];\r\n        const result = await _test(normalizedContext, value, {\r\n            name: rule,\r\n            params: normalizedContext.rules[rule],\r\n        });\r\n        if (result.error) {\r\n            errors.push(result.error);\r\n            if (field.bails) {\r\n                return {\r\n                    errors,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        errors,\r\n    };\r\n}\r\n/**\r\n * Handles yup validation\r\n */\r\nasync function validateFieldWithYup(value, validator, opts) {\r\n    var _a;\r\n    const errors = await validator\r\n        .validate(value, {\r\n        abortEarly: (_a = opts.bails) !== null && _a !== void 0 ? _a : true,\r\n    })\r\n        .then(() => [])\r\n        .catch((err) => {\r\n        // Yup errors have a name prop one them.\r\n        // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\r\n        if (err.name === 'ValidationError') {\r\n            return err.errors;\r\n        }\r\n        // re-throw the error so we don't hide it\r\n        throw err;\r\n    });\r\n    return {\r\n        errors,\r\n    };\r\n}\r\n/**\r\n * Tests a single input value against a rule.\r\n */\r\nasync function _test(field, value, rule) {\r\n    const validator = resolveRule(rule.name);\r\n    if (!validator) {\r\n        throw new Error(`No such validator '${rule.name}' exists.`);\r\n    }\r\n    const params = fillTargetValues(rule.params, field.formData);\r\n    const ctx = {\r\n        field: field.name,\r\n        value,\r\n        form: field.formData,\r\n        rule: Object.assign(Object.assign({}, rule), { params }),\r\n    };\r\n    const result = await validator(value, params, ctx);\r\n    if (typeof result === 'string') {\r\n        return {\r\n            error: result,\r\n        };\r\n    }\r\n    return {\r\n        error: result ? undefined : _generateFieldError(ctx),\r\n    };\r\n}\r\n/**\r\n * Generates error messages.\r\n */\r\nfunction _generateFieldError(fieldCtx) {\r\n    const message = getConfig().generateMessage;\r\n    if (!message) {\r\n        return 'Field is invalid';\r\n    }\r\n    return message(fieldCtx);\r\n}\r\nfunction fillTargetValues(params, crossTable) {\r\n    const normalize = (value) => {\r\n        if (isLocator(value)) {\r\n            return value(crossTable);\r\n        }\r\n        return value;\r\n    };\r\n    if (Array.isArray(params)) {\r\n        return params.map(normalize);\r\n    }\r\n    return Object.keys(params).reduce((acc, param) => {\r\n        acc[param] = normalize(params[param]);\r\n        return acc;\r\n    }, {});\r\n}\r\nasync function validateYupSchema(schema, values) {\r\n    const errorObjects = await schema\r\n        .validate(values, { abortEarly: false })\r\n        .then(() => [])\r\n        .catch((err) => {\r\n        // Yup errors have a name prop one them.\r\n        // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\r\n        if (err.name !== 'ValidationError') {\r\n            throw err;\r\n        }\r\n        // list of aggregated errors\r\n        return err.inner || [];\r\n    });\r\n    const results = {};\r\n    const errors = {};\r\n    for (const error of errorObjects) {\r\n        const messages = error.errors;\r\n        results[error.path] = { valid: !messages.length, errors: messages };\r\n        if (messages.length) {\r\n            errors[error.path] = messages[0];\r\n        }\r\n    }\r\n    return {\r\n        valid: !errorObjects.length,\r\n        results,\r\n        errors,\r\n    };\r\n}\r\nasync function validateObjectSchema(schema, values, opts) {\r\n    const paths = keysOf(schema);\r\n    const validations = paths.map(async (path) => {\r\n        var _a, _b, _c;\r\n        const fieldResult = await validate(getFromPath(values, path), schema[path], {\r\n            name: ((_a = opts === null || opts === void 0 ? void 0 : opts.names) === null || _a === void 0 ? void 0 : _a[path]) || path,\r\n            values: values,\r\n            bails: (_c = (_b = opts === null || opts === void 0 ? void 0 : opts.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true,\r\n        });\r\n        return Object.assign(Object.assign({}, fieldResult), { path });\r\n    });\r\n    let isAllValid = true;\r\n    const validationResults = await Promise.all(validations);\r\n    const results = {};\r\n    const errors = {};\r\n    for (const result of validationResults) {\r\n        results[result.path] = {\r\n            valid: result.valid,\r\n            errors: result.errors,\r\n        };\r\n        if (!result.valid) {\r\n            isAllValid = false;\r\n            errors[result.path] = result.errors[0];\r\n        }\r\n    }\r\n    return {\r\n        valid: isAllValid,\r\n        results,\r\n        errors,\r\n    };\r\n}\n\nfunction klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar k, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\tif (x.constructor !== Object && typeof x.constructor === 'function') {\n\t\t\ttmp = new x.constructor();\n\t\t\tfor (k in x) {\n\t\t\t\tif (tmp.hasOwnProperty(k) && tmp[k] !== x[k]) {\n\t\t\t\t\ttmp[k] = klona(x[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttmp = {}; // null\n\t\t\tfor (k in x) {\n\t\t\t\tif (k === '__proto__') {\n\t\t\t\t\tObject.defineProperty(tmp, k, {\n\t\t\t\t\t\tvalue: klona(x[k]),\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttmp[k] = klona(x[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Array]') {\n\t\tk = x.length;\n\t\tfor (tmp=Array(k); k--;) {\n\t\t\ttmp[k] = klona(x[k]);\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Date]') {\n\t\treturn new Date(+x);\n\t}\n\n\tif (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t\ttmp.lastIndex = x.lastIndex;\n\t\treturn tmp;\n\t}\n\n\treturn x;\n}\n\nvar es6 = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\nlet ID_COUNTER = 0;\r\n/**\r\n * Creates a field composite.\r\n */\r\nfunction useField(name, rules, opts) {\r\n    const fid = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;\r\n    const { initialValue, validateOnMount, bails, type, checkedValue, label, validateOnValueUpdate, uncheckedValue, standalone, } = normalizeOptions(unref(name), opts);\r\n    const form = !standalone ? injectWithSelf(FormContextKey) : undefined;\r\n    const { meta, errors, errorMessage, handleBlur, handleInput, resetValidationState, setValidationState, setErrors, value, checked, } = useValidationState({\r\n        name,\r\n        initValue: initialValue,\r\n        form,\r\n        type,\r\n        checkedValue,\r\n        standalone,\r\n    });\r\n    const normalizedRules = computed(() => {\r\n        let rulesValue = unref(rules);\r\n        const schema = unref(form === null || form === void 0 ? void 0 : form.schema);\r\n        if (schema && !isYupValidator(schema)) {\r\n            rulesValue = extractRuleFromSchema(schema, unref(name)) || rulesValue;\r\n        }\r\n        if (isYupValidator(rulesValue) || isCallable(rulesValue)) {\r\n            return rulesValue;\r\n        }\r\n        return normalizeRules(rulesValue);\r\n    });\r\n    async function validateCurrentValue(mode) {\r\n        var _a, _b;\r\n        if (form === null || form === void 0 ? void 0 : form.validateSchema) {\r\n            return (_a = (await form.validateSchema(mode)).results[unref(name)]) !== null && _a !== void 0 ? _a : { valid: true, errors: [] };\r\n        }\r\n        return validate(value.value, normalizedRules.value, {\r\n            name: unref(label) || unref(name),\r\n            values: (_b = form === null || form === void 0 ? void 0 : form.values) !== null && _b !== void 0 ? _b : {},\r\n            bails,\r\n        });\r\n    }\r\n    async function validateWithStateMutation() {\r\n        meta.pending = true;\r\n        meta.validated = true;\r\n        const result = await validateCurrentValue('validated-only');\r\n        meta.pending = false;\r\n        return setValidationState(result);\r\n    }\r\n    async function validateValidStateOnly() {\r\n        const result = await validateCurrentValue('silent');\r\n        meta.valid = result.valid;\r\n    }\r\n    // Common input/change event handler\r\n    const handleChange = (e, shouldValidate = true) => {\r\n        var _a, _b;\r\n        if (checked && checked.value === ((_b = (_a = e) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.checked)) {\r\n            return;\r\n        }\r\n        let newValue = normalizeEventValue(e);\r\n        // Single checkbox field without a form to toggle it's value\r\n        if (checked && type === 'checkbox' && !form) {\r\n            newValue = resolveNextCheckboxValue(value.value, unref(checkedValue), unref(uncheckedValue));\r\n        }\r\n        value.value = newValue;\r\n        if (!validateOnValueUpdate && shouldValidate) {\r\n            return validateWithStateMutation();\r\n        }\r\n    };\r\n    // Runs the initial validation\r\n    onMounted(() => {\r\n        if (validateOnMount) {\r\n            return validateWithStateMutation();\r\n        }\r\n        // validate self initially if no form was handling this\r\n        // forms should have their own initial silent validation run to make things more efficient\r\n        if (!form || !form.validateSchema) {\r\n            validateValidStateOnly();\r\n        }\r\n    });\r\n    function setTouched(isTouched) {\r\n        meta.touched = isTouched;\r\n    }\r\n    let unwatchValue;\r\n    function watchValue() {\r\n        unwatchValue = watch(value, validateOnValueUpdate ? validateWithStateMutation : validateValidStateOnly, {\r\n            deep: true,\r\n        });\r\n    }\r\n    watchValue();\r\n    function resetField(state) {\r\n        unwatchValue === null || unwatchValue === void 0 ? void 0 : unwatchValue();\r\n        resetValidationState(state);\r\n        // need to watch at next tick to avoid triggering the value watcher\r\n        nextTick(() => {\r\n            watchValue();\r\n        });\r\n    }\r\n    const field = {\r\n        idx: -1,\r\n        fid,\r\n        name,\r\n        label,\r\n        value,\r\n        meta,\r\n        errors,\r\n        errorMessage,\r\n        type,\r\n        checkedValue,\r\n        uncheckedValue,\r\n        checked,\r\n        bails,\r\n        resetField,\r\n        handleReset: () => resetField(),\r\n        validate: validateWithStateMutation,\r\n        handleChange,\r\n        handleBlur,\r\n        handleInput,\r\n        setValidationState,\r\n        setTouched,\r\n        setErrors,\r\n    };\r\n    provide(FieldContextKey, field);\r\n    if (isRef(rules) && typeof unref(rules) !== 'function') {\r\n        watch(rules, (value, oldValue) => {\r\n            if (es6(value, oldValue)) {\r\n                return;\r\n            }\r\n            return validateWithStateMutation();\r\n        }, {\r\n            deep: true,\r\n        });\r\n    }\r\n    // if no associated form return the field API immediately\r\n    if (!form) {\r\n        return field;\r\n    }\r\n    // associate the field with the given form\r\n    form.register(field);\r\n    onBeforeUnmount(() => {\r\n        form.unregister(field);\r\n    });\r\n    // extract cross-field dependencies in a computed prop\r\n    const dependencies = computed(() => {\r\n        const rulesVal = normalizedRules.value;\r\n        // is falsy, a function schema or a yup schema\r\n        if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal)) {\r\n            return {};\r\n        }\r\n        return Object.keys(rulesVal).reduce((acc, rule) => {\r\n            const deps = extractLocators(rulesVal[rule])\r\n                .map((dep) => dep.__locatorRef)\r\n                .reduce((depAcc, depName) => {\r\n                const depValue = getFromPath(form.values, depName) || form.values[depName];\r\n                if (depValue !== undefined) {\r\n                    depAcc[depName] = depValue;\r\n                }\r\n                return depAcc;\r\n            }, {});\r\n            Object.assign(acc, deps);\r\n            return acc;\r\n        }, {});\r\n    });\r\n    // Adds a watcher that runs the validation whenever field dependencies change\r\n    watch(dependencies, (deps, oldDeps) => {\r\n        // Skip if no dependencies or if the field wasn't manipulated\r\n        if (!Object.keys(deps).length) {\r\n            return;\r\n        }\r\n        const shouldValidate = !es6(deps, oldDeps);\r\n        if (shouldValidate) {\r\n            meta.dirty ? validateWithStateMutation() : validateValidStateOnly();\r\n        }\r\n    });\r\n    return field;\r\n}\r\n/**\r\n * Normalizes partial field options to include the full options\r\n */\r\nfunction normalizeOptions(name, opts) {\r\n    const defaults = () => ({\r\n        initialValue: undefined,\r\n        validateOnMount: false,\r\n        bails: true,\r\n        rules: '',\r\n        label: name,\r\n        validateOnValueUpdate: true,\r\n        standalone: false,\r\n    });\r\n    if (!opts) {\r\n        return defaults();\r\n    }\r\n    // TODO: Deprecate this in next major release\r\n    const checkedValue = 'valueProp' in opts ? opts.valueProp : opts.checkedValue;\r\n    return Object.assign(Object.assign(Object.assign({}, defaults()), (opts || {})), { checkedValue });\r\n}\r\n/**\r\n * Manages the validation state of a field.\r\n */\r\nfunction useValidationState({ name, initValue, form, type, checkedValue, standalone, }) {\r\n    const { errors, errorMessage, setErrors } = useFieldErrors(name, form);\r\n    const formInitialValues = standalone ? undefined : injectWithSelf(FormInitialValuesKey, undefined);\r\n    // clones the ref value to a mutable version\r\n    const initialValueRef = ref(unref(initValue));\r\n    const initialValue = computed(() => {\r\n        return getFromPath(unref(formInitialValues), unref(name), unref(initialValueRef));\r\n    });\r\n    const value = useFieldValue$1(initialValue, name, form);\r\n    const meta = useFieldMeta(initialValue, value, errors);\r\n    const checked = hasCheckedAttr(type)\r\n        ? computed(() => {\r\n            if (Array.isArray(value.value)) {\r\n                return value.value.includes(unref(checkedValue));\r\n            }\r\n            return unref(checkedValue) === value.value;\r\n        })\r\n        : undefined;\r\n    /**\r\n     * Handles common onBlur meta update\r\n     */\r\n    const handleBlur = () => {\r\n        meta.touched = true;\r\n    };\r\n    /**\r\n     * Handles common on blur events\r\n     * @deprecated You should use `handleChange` instead\r\n     */\r\n    const handleInput = (e) => {\r\n        // Checkboxes/Radio will emit a `change` event anyway, custom components will use `update:modelValue`\r\n        // so this is redundant\r\n        if (!hasCheckedAttr(type)) {\r\n            value.value = normalizeEventValue(e);\r\n        }\r\n    };\r\n    // Updates the validation state with the validation result\r\n    function setValidationState(result) {\r\n        setErrors(result.errors);\r\n        return result;\r\n    }\r\n    // Resets the validation state\r\n    function resetValidationState(state) {\r\n        var _a;\r\n        const fieldPath = unref(name);\r\n        const newValue = state && 'value' in state\r\n            ? state.value\r\n            : getFromPath(unref(formInitialValues), fieldPath, unref(initValue));\r\n        if (form) {\r\n            form.setFieldValue(fieldPath, newValue, { force: true });\r\n            form.setFieldInitialValue(fieldPath, newValue);\r\n        }\r\n        else {\r\n            value.value = klona(newValue);\r\n            initialValueRef.value = klona(newValue);\r\n        }\r\n        setErrors((state === null || state === void 0 ? void 0 : state.errors) || []);\r\n        meta.touched = (_a = state === null || state === void 0 ? void 0 : state.touched) !== null && _a !== void 0 ? _a : false;\r\n        meta.pending = false;\r\n        meta.validated = false;\r\n    }\r\n    return {\r\n        meta,\r\n        errors,\r\n        errorMessage,\r\n        setErrors,\r\n        setValidationState,\r\n        resetValidationState,\r\n        handleBlur,\r\n        handleInput,\r\n        value,\r\n        checked,\r\n    };\r\n}\r\n/**\r\n * Exposes meta flags state and some associated actions with them.\r\n */\r\nfunction useFieldMeta(initialValue, currentValue, errors) {\r\n    const meta = reactive({\r\n        touched: false,\r\n        pending: false,\r\n        valid: true,\r\n        validated: !!unref(errors).length,\r\n        initialValue: computed(() => unref(initialValue)),\r\n        dirty: computed(() => {\r\n            return !es6(unref(currentValue), unref(initialValue));\r\n        }),\r\n    });\r\n    watch(errors, value => {\r\n        meta.valid = !value.length;\r\n    }, {\r\n        immediate: true,\r\n        flush: 'sync',\r\n    });\r\n    return meta;\r\n}\r\n/**\r\n * Extracts the validation rules from a schema\r\n */\r\nfunction extractRuleFromSchema(schema, fieldName) {\r\n    // no schema at all\r\n    if (!schema) {\r\n        return undefined;\r\n    }\r\n    // there is a key on the schema object for this field\r\n    return schema[fieldName];\r\n}\r\n/**\r\n * Manages the field value\r\n */\r\nfunction useFieldValue$1(initialValue, path, form) {\r\n    // if no form is associated, use a regular ref.\r\n    if (!form) {\r\n        return ref(unref(initialValue));\r\n    }\r\n    // to set the initial value, first check if there is a current value, if there is then use it.\r\n    // otherwise use the configured initial value if it exists.\r\n    // #3429\r\n    const currentValue = getFromPath(form.values, unref(path), unref(initialValue));\r\n    form.stageInitialValue(unref(path), currentValue === undefined ? unref(initialValue) : currentValue);\r\n    // otherwise use a computed setter that triggers the `setFieldValue`\r\n    const value = computed({\r\n        get() {\r\n            return getFromPath(form.values, unref(path));\r\n        },\r\n        set(newVal) {\r\n            form.setFieldValue(unref(path), newVal);\r\n        },\r\n    });\r\n    return value;\r\n}\r\nfunction useFieldErrors(path, form) {\r\n    if (!form) {\r\n        const errors = ref([]);\r\n        return {\r\n            errors: computed(() => errors.value),\r\n            errorMessage: computed(() => errors.value[0]),\r\n            setErrors: (messages) => {\r\n                errors.value = Array.isArray(messages) ? messages : [messages];\r\n            },\r\n        };\r\n    }\r\n    const errors = computed(() => form.errorBag.value[unref(path)] || []);\r\n    return {\r\n        errors,\r\n        errorMessage: computed(() => errors.value[0]),\r\n        setErrors: (messages) => {\r\n            form.setFieldErrorBag(unref(path), messages);\r\n        },\r\n    };\r\n}\n\nconst Field = defineComponent({\r\n    name: 'Field',\r\n    inheritAttrs: false,\r\n    props: {\r\n        as: {\r\n            type: [String, Object],\r\n            default: undefined,\r\n        },\r\n        name: {\r\n            type: String,\r\n            required: true,\r\n        },\r\n        rules: {\r\n            type: [Object, String, Function],\r\n            default: undefined,\r\n        },\r\n        validateOnMount: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        validateOnBlur: {\r\n            type: Boolean,\r\n            default: undefined,\r\n        },\r\n        validateOnChange: {\r\n            type: Boolean,\r\n            default: undefined,\r\n        },\r\n        validateOnInput: {\r\n            type: Boolean,\r\n            default: undefined,\r\n        },\r\n        validateOnModelUpdate: {\r\n            type: Boolean,\r\n            default: undefined,\r\n        },\r\n        bails: {\r\n            type: Boolean,\r\n            default: () => getConfig().bails,\r\n        },\r\n        label: {\r\n            type: String,\r\n            default: undefined,\r\n        },\r\n        uncheckedValue: {\r\n            type: null,\r\n            default: undefined,\r\n        },\r\n        modelValue: {\r\n            type: null,\r\n            default: IS_ABSENT,\r\n        },\r\n        modelModifiers: {\r\n            type: null,\r\n            default: () => ({}),\r\n        },\r\n        'onUpdate:modelValue': {\r\n            type: null,\r\n            default: undefined,\r\n        },\r\n        standalone: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n    },\r\n    setup(props, ctx) {\r\n        const rules = toRef(props, 'rules');\r\n        const name = toRef(props, 'name');\r\n        const label = toRef(props, 'label');\r\n        const uncheckedValue = toRef(props, 'uncheckedValue');\r\n        const hasModelEvents = isPropPresent(props, 'onUpdate:modelValue');\r\n        const { errors, value, errorMessage, validate: validateField, handleChange, handleBlur, handleInput, setTouched, resetField, handleReset, meta, checked, setErrors, } = useField(name, rules, {\r\n            validateOnMount: props.validateOnMount,\r\n            bails: props.bails,\r\n            standalone: props.standalone,\r\n            type: ctx.attrs.type,\r\n            initialValue: resolveInitialValue(props, ctx),\r\n            // Only for checkboxes and radio buttons\r\n            checkedValue: ctx.attrs.value,\r\n            uncheckedValue,\r\n            label,\r\n            validateOnValueUpdate: false,\r\n        });\r\n        // If there is a v-model applied on the component we need to emit the `update:modelValue` whenever the value binding changes\r\n        const onChangeHandler = hasModelEvents\r\n            ? function handleChangeWithModel(e, shouldValidate = true) {\r\n                handleChange(e, shouldValidate);\r\n                ctx.emit('update:modelValue', value.value);\r\n            }\r\n            : handleChange;\r\n        const onInputHandler = hasModelEvents\r\n            ? function handleChangeWithModel(e) {\r\n                handleInput(e);\r\n                ctx.emit('update:modelValue', value.value);\r\n            }\r\n            : handleInput;\r\n        const fieldProps = computed(() => {\r\n            const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = resolveValidationTriggers(props);\r\n            const baseOnBlur = [handleBlur, ctx.attrs.onBlur, validateOnBlur ? validateField : undefined].filter(Boolean);\r\n            const baseOnInput = [(e) => onChangeHandler(e, validateOnInput), ctx.attrs.onInput].filter(Boolean);\r\n            const baseOnChange = [(e) => onChangeHandler(e, validateOnChange), ctx.attrs.onChange].filter(Boolean);\r\n            const attrs = {\r\n                name: props.name,\r\n                onBlur: baseOnBlur,\r\n                onInput: baseOnInput,\r\n                onChange: baseOnChange,\r\n            };\r\n            if (validateOnModelUpdate) {\r\n                attrs['onUpdate:modelValue'] = [onChangeHandler];\r\n            }\r\n            if (hasCheckedAttr(ctx.attrs.type) && checked) {\r\n                attrs.checked = checked.value;\r\n            }\r\n            else {\r\n                attrs.value = value.value;\r\n            }\r\n            const tag = resolveTag(props, ctx);\r\n            if (shouldHaveValueBinding(tag, ctx.attrs)) {\r\n                delete attrs.value;\r\n            }\r\n            return attrs;\r\n        });\r\n        const modelValue = toRef(props, 'modelValue');\r\n        watch(modelValue, newModelValue => {\r\n            // Don't attempt to sync absent values\r\n            if (newModelValue === IS_ABSENT && value.value === undefined) {\r\n                return;\r\n            }\r\n            if (newModelValue !== applyModifiers(value.value, props.modelModifiers)) {\r\n                value.value = newModelValue;\r\n                validateField();\r\n            }\r\n        });\r\n        function slotProps() {\r\n            return {\r\n                field: fieldProps.value,\r\n                value: value.value,\r\n                meta,\r\n                errors: errors.value,\r\n                errorMessage: errorMessage.value,\r\n                validate: validateField,\r\n                resetField,\r\n                handleChange: onChangeHandler,\r\n                handleInput: onInputHandler,\r\n                handleReset,\r\n                handleBlur,\r\n                setTouched,\r\n                setErrors,\r\n            };\r\n        }\r\n        return () => {\r\n            const tag = resolveDynamicComponent(resolveTag(props, ctx));\r\n            const children = normalizeChildren(tag, ctx, slotProps);\r\n            if (tag) {\r\n                return h(tag, Object.assign(Object.assign({}, ctx.attrs), fieldProps.value), children);\r\n            }\r\n            return children;\r\n        };\r\n    },\r\n});\r\nfunction resolveTag(props, ctx) {\r\n    let tag = props.as || '';\r\n    if (!props.as && !ctx.slots.default) {\r\n        tag = 'input';\r\n    }\r\n    return tag;\r\n}\r\nfunction resolveValidationTriggers(props) {\r\n    var _a, _b, _c, _d;\r\n    const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = getConfig();\r\n    return {\r\n        validateOnInput: (_a = props.validateOnInput) !== null && _a !== void 0 ? _a : validateOnInput,\r\n        validateOnChange: (_b = props.validateOnChange) !== null && _b !== void 0 ? _b : validateOnChange,\r\n        validateOnBlur: (_c = props.validateOnBlur) !== null && _c !== void 0 ? _c : validateOnBlur,\r\n        validateOnModelUpdate: (_d = props.validateOnModelUpdate) !== null && _d !== void 0 ? _d : validateOnModelUpdate,\r\n    };\r\n}\r\nfunction applyModifiers(value, modifiers) {\r\n    if (modifiers.number) {\r\n        return toNumber(value);\r\n    }\r\n    return value;\r\n}\r\nfunction resolveInitialValue(props, ctx) {\r\n    // Gets the initial value either from `value` prop/attr or `v-model` binding (modelValue)\r\n    // For checkboxes and radio buttons it will always be the model value not the `value` attribute\r\n    if (!hasCheckedAttr(ctx.attrs.type)) {\r\n        return isPropPresent(props, 'modelValue') ? props.modelValue : ctx.attrs.value;\r\n    }\r\n    return isPropPresent(props, 'modelValue') ? props.modelValue : undefined;\r\n}\n\nfunction useForm(opts) {\r\n    // A flat array containing field references\r\n    const fields = ref([]);\r\n    // If the form is currently submitting\r\n    const isSubmitting = ref(false);\r\n    // a field map object useful for faster access of fields\r\n    const fieldsById = computed(() => {\r\n        return fields.value.reduce((acc, field) => {\r\n            const fieldPath = unref(field.name);\r\n            // if the field was not added before\r\n            if (!acc[fieldPath]) {\r\n                acc[fieldPath] = field;\r\n                field.idx = -1;\r\n                return acc;\r\n            }\r\n            // if the same name is detected\r\n            const existingField = acc[fieldPath];\r\n            if (!Array.isArray(existingField)) {\r\n                existingField.idx = 0;\r\n                acc[fieldPath] = [existingField];\r\n            }\r\n            const fieldGroup = acc[fieldPath];\r\n            field.idx = fieldGroup.length;\r\n            fieldGroup.push(field);\r\n            return acc;\r\n        }, {});\r\n    });\r\n    // The number of times the user tried to submit the form\r\n    const submitCount = ref(0);\r\n    // a private ref for all form values\r\n    const formValues = reactive(klona(unref(opts === null || opts === void 0 ? void 0 : opts.initialValues) || {}));\r\n    // a lookup to keep track of values by their field ids\r\n    // this is important because later we need it if fields swap names\r\n    const valuesByFid = {};\r\n    // the source of errors for the form fields\r\n    const { errorBag, setErrorBag, setFieldErrorBag } = useErrorBag(opts === null || opts === void 0 ? void 0 : opts.initialErrors);\r\n    // Gets the first error of each field\r\n    const errors = computed(() => {\r\n        return keysOf(errorBag.value).reduce((acc, key) => {\r\n            const bag = errorBag.value[key];\r\n            if (bag && bag.length) {\r\n                acc[key] = bag[0];\r\n            }\r\n            return acc;\r\n        }, {});\r\n    });\r\n    /**\r\n     * Holds a computed reference to all fields names and labels\r\n     */\r\n    const fieldNames = computed(() => {\r\n        return keysOf(fieldsById.value).reduce((names, path) => {\r\n            const field = normalizeField(fieldsById.value[path]);\r\n            if (field) {\r\n                names[path] = unref(field.label || field.name) || '';\r\n            }\r\n            return names;\r\n        }, {});\r\n    });\r\n    const fieldBailsMap = computed(() => {\r\n        return keysOf(fieldsById.value).reduce((map, path) => {\r\n            var _a;\r\n            const field = normalizeField(fieldsById.value[path]);\r\n            if (field) {\r\n                map[path] = (_a = field.bails) !== null && _a !== void 0 ? _a : true;\r\n            }\r\n            return map;\r\n        }, {});\r\n    });\r\n    // mutable non-reactive reference to initial errors\r\n    // we need this to process initial errors then unset them\r\n    const initialErrors = Object.assign({}, ((opts === null || opts === void 0 ? void 0 : opts.initialErrors) || {}));\r\n    // initial form values\r\n    const { readonlyInitialValues, initialValues, setInitialValues } = useFormInitialValues(fieldsById, formValues, opts === null || opts === void 0 ? void 0 : opts.initialValues);\r\n    // form meta aggregations\r\n    const meta = useFormMeta(fields, formValues, readonlyInitialValues, errors);\r\n    const schema = opts === null || opts === void 0 ? void 0 : opts.validationSchema;\r\n    const formCtx = {\r\n        fieldsById,\r\n        values: formValues,\r\n        errorBag,\r\n        schema,\r\n        submitCount,\r\n        meta,\r\n        isSubmitting,\r\n        validateSchema: unref(schema) ? validateSchema : undefined,\r\n        validate,\r\n        register: registerField,\r\n        unregister: unregisterField,\r\n        setFieldErrorBag,\r\n        validateField,\r\n        setFieldValue,\r\n        setValues,\r\n        setErrors,\r\n        setFieldError,\r\n        setFieldTouched,\r\n        setTouched,\r\n        resetForm,\r\n        handleSubmit,\r\n        stageInitialValue,\r\n        setFieldInitialValue,\r\n    };\r\n    /**\r\n     * Manually sets an error message on a specific field\r\n     */\r\n    function setFieldError(field, message) {\r\n        setFieldErrorBag(field, message);\r\n    }\r\n    /**\r\n     * Sets errors for the fields specified in the object\r\n     */\r\n    function setErrors(fields) {\r\n        setErrorBag(fields);\r\n    }\r\n    /**\r\n     * Sets a single field value\r\n     */\r\n    function setFieldValue(field, value, { force } = { force: false }) {\r\n        var _a;\r\n        const fieldInstance = fieldsById.value[field];\r\n        const clonedValue = klona(value);\r\n        // field wasn't found, create a virtual field as a placeholder\r\n        if (!fieldInstance) {\r\n            setInPath(formValues, field, clonedValue);\r\n            return;\r\n        }\r\n        // Multiple checkboxes, and only one of them got updated\r\n        if (Array.isArray(fieldInstance) && ((_a = fieldInstance[0]) === null || _a === void 0 ? void 0 : _a.type) === 'checkbox' && !Array.isArray(value)) {\r\n            const newVal = klona(resolveNextCheckboxValue(getFromPath(formValues, field) || [], value, undefined));\r\n            setInPath(formValues, field, newVal);\r\n            fieldInstance.forEach(fieldItem => {\r\n                valuesByFid[fieldItem.fid] = newVal;\r\n            });\r\n            return;\r\n        }\r\n        let newValue = value;\r\n        // Single Checkbox: toggles the field value unless the field is being reset then force it\r\n        if (!Array.isArray(fieldInstance) && (fieldInstance === null || fieldInstance === void 0 ? void 0 : fieldInstance.type) === 'checkbox' && !force) {\r\n            newValue = klona(resolveNextCheckboxValue(getFromPath(formValues, field), value, unref(fieldInstance.uncheckedValue)));\r\n        }\r\n        setInPath(formValues, field, newValue);\r\n        // multiple radio fields\r\n        if (fieldInstance && Array.isArray(fieldInstance)) {\r\n            fieldInstance.forEach(fieldItem => {\r\n                valuesByFid[fieldItem.fid] = newValue;\r\n            });\r\n            return;\r\n        }\r\n        valuesByFid[fieldInstance.fid] = newValue;\r\n    }\r\n    /**\r\n     * Sets multiple fields values\r\n     */\r\n    function setValues(fields) {\r\n        // clean up old values\r\n        keysOf(formValues).forEach(key => {\r\n            delete formValues[key];\r\n        });\r\n        // set up new values\r\n        keysOf(fields).forEach(path => {\r\n            setFieldValue(path, fields[path]);\r\n        });\r\n    }\r\n    /**\r\n     * Sets the touched meta state on a field\r\n     */\r\n    function setFieldTouched(field, isTouched) {\r\n        const fieldInstance = fieldsById.value[field];\r\n        if (!fieldInstance) {\r\n            return;\r\n        }\r\n        applyFieldMutation(fieldInstance, f => f.setTouched(isTouched));\r\n    }\r\n    /**\r\n     * Sets the touched meta state on multiple fields\r\n     */\r\n    function setTouched(fields) {\r\n        keysOf(fields).forEach(field => {\r\n            setFieldTouched(field, !!fields[field]);\r\n        });\r\n    }\r\n    /**\r\n     * Resets all fields\r\n     */\r\n    function resetForm(state) {\r\n        // set initial values if provided\r\n        if (state === null || state === void 0 ? void 0 : state.values) {\r\n            setInitialValues(state.values);\r\n            setValues(state === null || state === void 0 ? void 0 : state.values);\r\n        }\r\n        else {\r\n            // otherwise clean the current values\r\n            setValues(initialValues.value);\r\n        }\r\n        // Reset all fields state\r\n        fields.value.forEach(f => f.resetField());\r\n        if (state === null || state === void 0 ? void 0 : state.touched) {\r\n            setTouched(state.touched);\r\n        }\r\n        setErrors((state === null || state === void 0 ? void 0 : state.errors) || {});\r\n        submitCount.value = (state === null || state === void 0 ? void 0 : state.submitCount) || 0;\r\n    }\r\n    function registerField(field) {\r\n        fields.value.push(field);\r\n        // TODO: Do this automatically on registration\r\n        // eslint-disable-next-line no-unused-expressions\r\n        fieldsById.value; // force computation of the fields ids to properly set their idx\r\n        if (isRef(field.name)) {\r\n            valuesByFid[field.fid] = field.value.value;\r\n            // ensures when a field's name was already taken that it preserves its same value\r\n            // necessary for fields generated by loops\r\n            watch(field.name, (newPath, oldPath) => {\r\n                setFieldValue(newPath, valuesByFid[field.fid]);\r\n                const isSharingName = fields.value.find(f => unref(f.name) === oldPath);\r\n                // clean up the old path if no other field is sharing that name\r\n                // #3325\r\n                if (!isSharingName) {\r\n                    unsetPath(formValues, oldPath);\r\n                    unsetPath(initialValues.value, oldPath);\r\n                }\r\n            }, {\r\n                flush: 'post',\r\n            });\r\n        }\r\n        // if field already had errors (initial errors) that's not user-set, validate it again to ensure state is correct\r\n        // the difference being that `initialErrors` will contain the error message while other errors (pre-validated schema) won't have them as initial errors\r\n        // #3342\r\n        const path = unref(field.name);\r\n        const initialErrorMessage = unref(field.errorMessage);\r\n        if (initialErrorMessage && (initialErrors === null || initialErrors === void 0 ? void 0 : initialErrors[path]) !== initialErrorMessage) {\r\n            validateField(path);\r\n        }\r\n        // marks the initial error as \"consumed\" so it won't be matched later with same non-initial error\r\n        delete initialErrors[path];\r\n    }\r\n    function unregisterField(field) {\r\n        var _a, _b;\r\n        const idx = fields.value.indexOf(field);\r\n        if (idx === -1) {\r\n            return;\r\n        }\r\n        fields.value.splice(idx, 1);\r\n        const fid = field.fid;\r\n        // cleans up the field value from fid lookup\r\n        nextTick(() => {\r\n            delete valuesByFid[fid];\r\n            // clears a field error on unmounted\r\n            // we wait till next tick to make sure if the field is completely removed and doesn't have any siblings like checkboxes\r\n            // #3384\r\n            if (!fieldsById.value[fieldName]) {\r\n                setFieldError(fieldName, undefined);\r\n            }\r\n        });\r\n        const fieldName = unref(field.name);\r\n        // in this case, this is a single field not a group (checkbox or radio)\r\n        // so remove the field value key immediately\r\n        if (field.idx === -1) {\r\n            // avoid un-setting the value if the field was switched with another that shares the same name\r\n            // they will be unset once the new field takes over the new name, look at `#registerField()`\r\n            // #3166\r\n            const isSharingName = fields.value.find(f => unref(f.name) === fieldName);\r\n            if (isSharingName) {\r\n                return;\r\n            }\r\n            unsetPath(formValues, fieldName);\r\n            unsetPath(initialValues.value, fieldName);\r\n            return;\r\n        }\r\n        // otherwise find the actual value in the current array of values and remove it\r\n        const valueIdx = (_b = (_a = getFromPath(formValues, fieldName)) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, unref(field.checkedValue));\r\n        if (valueIdx === undefined) {\r\n            unsetPath(formValues, fieldName);\r\n            return;\r\n        }\r\n        if (valueIdx === -1) {\r\n            return;\r\n        }\r\n        if (Array.isArray(formValues[fieldName])) {\r\n            unsetPath(formValues, `${fieldName}.${valueIdx}`);\r\n            return;\r\n        }\r\n        unsetPath(formValues, fieldName);\r\n        unsetPath(initialValues.value, fieldName);\r\n    }\r\n    async function validate() {\r\n        if (formCtx.validateSchema) {\r\n            return formCtx.validateSchema('force');\r\n        }\r\n        // No schema, each field is responsible to validate itself\r\n        const validations = await Promise.all(fields.value.map(f => {\r\n            return f.validate().then((result) => {\r\n                return {\r\n                    key: unref(f.name),\r\n                    valid: result.valid,\r\n                    errors: result.errors,\r\n                };\r\n            });\r\n        }));\r\n        const results = {};\r\n        const errors = {};\r\n        for (const validation of validations) {\r\n            results[validation.key] = {\r\n                valid: validation.valid,\r\n                errors: validation.errors,\r\n            };\r\n            if (validation.errors.length) {\r\n                errors[validation.key] = validation.errors[0];\r\n            }\r\n        }\r\n        return {\r\n            valid: validations.every(r => r.valid),\r\n            results,\r\n            errors,\r\n        };\r\n    }\r\n    async function validateField(field) {\r\n        const fieldInstance = fieldsById.value[field];\r\n        if (!fieldInstance) {\r\n            warn$1(`field with name ${field} was not found`);\r\n            return Promise.resolve({ errors: [], valid: true });\r\n        }\r\n        if (Array.isArray(fieldInstance)) {\r\n            return fieldInstance.map(f => f.validate())[0];\r\n        }\r\n        return fieldInstance.validate();\r\n    }\r\n    function handleSubmit(fn) {\r\n        return function submissionHandler(e) {\r\n            if (e instanceof Event) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n            }\r\n            // Touch all fields\r\n            setTouched(keysOf(fieldsById.value).reduce((acc, field) => {\r\n                acc[field] = true;\r\n                return acc;\r\n            }, {}));\r\n            isSubmitting.value = true;\r\n            submitCount.value++;\r\n            return validate()\r\n                .then(result => {\r\n                if (result.valid && typeof fn === 'function') {\r\n                    return fn(klona(formValues), {\r\n                        evt: e,\r\n                        setErrors,\r\n                        setFieldError,\r\n                        setTouched,\r\n                        setFieldTouched,\r\n                        setValues,\r\n                        setFieldValue,\r\n                        resetForm,\r\n                    });\r\n                }\r\n            })\r\n                .then(() => {\r\n                isSubmitting.value = false;\r\n            }, err => {\r\n                isSubmitting.value = false;\r\n                // re-throw the err so it doesn't go silent\r\n                throw err;\r\n            });\r\n        };\r\n    }\r\n    function setFieldInitialValue(path, value) {\r\n        setInPath(initialValues.value, path, klona(value));\r\n    }\r\n    /**\r\n     * Sneaky function to set initial field values\r\n     */\r\n    function stageInitialValue(path, value) {\r\n        setInPath(formValues, path, value);\r\n        setFieldInitialValue(path, value);\r\n    }\r\n    async function validateSchema(mode) {\r\n        const schemaValue = unref(schema);\r\n        if (!schemaValue) {\r\n            return { valid: true, results: {}, errors: {} };\r\n        }\r\n        const formResult = isYupValidator(schemaValue)\r\n            ? await validateYupSchema(schemaValue, formValues)\r\n            : await validateObjectSchema(schemaValue, formValues, {\r\n                names: fieldNames.value,\r\n                bailsMap: fieldBailsMap.value,\r\n            });\r\n        // fields by id lookup\r\n        const fieldsById = formCtx.fieldsById.value || {};\r\n        // errors fields names, we need it to also check if custom errors are updated\r\n        const currentErrorsPaths = keysOf(formCtx.errorBag.value);\r\n        // collect all the keys from the schema and all fields\r\n        // this ensures we have a complete keymap of all the fields\r\n        const paths = [\r\n            ...new Set([...keysOf(formResult.results), ...keysOf(fieldsById), ...currentErrorsPaths]),\r\n        ];\r\n        // aggregates the paths into a single result object while applying the results on the fields\r\n        return paths.reduce((validation, path) => {\r\n            const field = fieldsById[path];\r\n            const messages = (formResult.results[path] || { errors: [] }).errors;\r\n            const fieldResult = {\r\n                errors: messages,\r\n                valid: !messages.length,\r\n            };\r\n            validation.results[path] = fieldResult;\r\n            if (!fieldResult.valid) {\r\n                validation.errors[path] = fieldResult.errors[0];\r\n            }\r\n            // field not rendered\r\n            if (!field) {\r\n                setFieldError(path, messages);\r\n                return validation;\r\n            }\r\n            // always update the valid flag regardless of the mode\r\n            applyFieldMutation(field, f => (f.meta.valid = fieldResult.valid));\r\n            if (mode === 'silent') {\r\n                return validation;\r\n            }\r\n            const wasValidated = Array.isArray(field) ? field.some(f => f.meta.validated) : field.meta.validated;\r\n            if (mode === 'validated-only' && !wasValidated) {\r\n                return validation;\r\n            }\r\n            applyFieldMutation(field, f => f.setValidationState(fieldResult), true);\r\n            return validation;\r\n        }, { valid: formResult.valid, results: {}, errors: {} });\r\n    }\r\n    const submitForm = handleSubmit((_, { evt }) => {\r\n        if (isFormSubmitEvent(evt)) {\r\n            evt.target.submit();\r\n        }\r\n    });\r\n    // Trigger initial validation\r\n    onMounted(() => {\r\n        if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {\r\n            setErrors(opts.initialErrors);\r\n        }\r\n        if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {\r\n            setTouched(opts.initialTouched);\r\n        }\r\n        // if validate on mount was enabled\r\n        if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {\r\n            validate();\r\n            return;\r\n        }\r\n        // otherwise run initial silent validation through schema if available\r\n        // the useField should skip their own silent validation if a yup schema is present\r\n        if (formCtx.validateSchema) {\r\n            formCtx.validateSchema('silent');\r\n        }\r\n    });\r\n    if (isRef(schema)) {\r\n        watch(schema, () => {\r\n            var _a;\r\n            (_a = formCtx.validateSchema) === null || _a === void 0 ? void 0 : _a.call(formCtx, 'validated-only');\r\n        });\r\n    }\r\n    // Provide injections\r\n    provide(FormContextKey, formCtx);\r\n    provide(FormErrorsKey, errors);\r\n    return {\r\n        errors,\r\n        meta,\r\n        values: formValues,\r\n        isSubmitting,\r\n        submitCount,\r\n        validate,\r\n        validateField,\r\n        handleReset: () => resetForm(),\r\n        resetForm,\r\n        handleSubmit,\r\n        submitForm,\r\n        setFieldError,\r\n        setErrors,\r\n        setFieldValue,\r\n        setValues,\r\n        setFieldTouched,\r\n        setTouched,\r\n    };\r\n}\r\n/**\r\n * Manages form meta aggregation\r\n */\r\nfunction useFormMeta(fields, currentValues, initialValues, errors) {\r\n    const MERGE_STRATEGIES = {\r\n        touched: 'some',\r\n        pending: 'some',\r\n        valid: 'every',\r\n    };\r\n    const isDirty = computed(() => {\r\n        return !es6(currentValues, unref(initialValues));\r\n    });\r\n    const flags = computed(() => {\r\n        return keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {\r\n            const mergeMethod = MERGE_STRATEGIES[flag];\r\n            acc[flag] = fields.value[mergeMethod](field => field.meta[flag]);\r\n            return acc;\r\n        }, {});\r\n    });\r\n    return computed(() => {\r\n        return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags.value), { valid: flags.value.valid && !keysOf(errors.value).length, dirty: isDirty.value });\r\n    });\r\n}\r\n/**\r\n * Manages the initial values prop\r\n */\r\nfunction useFormInitialValues(fields, formValues, providedValues) {\r\n    const initialValues = ref(unref(providedValues) || {});\r\n    // acts as a read only proxy of the initial values object\r\n    const computedInitials = computed(() => {\r\n        return initialValues.value;\r\n    });\r\n    function setInitialValues(values, updateFields = false) {\r\n        initialValues.value = klona(values);\r\n        if (!updateFields) {\r\n            return;\r\n        }\r\n        // update the pristine non-touched fields\r\n        // those are excluded because it's unlikely you want to change the form values using initial values\r\n        // we mostly watch them for API population or newly inserted fields\r\n        // if the user API is taking too much time before user interaction they should consider disabling or hiding their inputs until the values are ready\r\n        const hadInteraction = (f) => f.meta.touched;\r\n        keysOf(fields.value).forEach(fieldPath => {\r\n            const field = fields.value[fieldPath];\r\n            const touchedByUser = Array.isArray(field) ? field.some(hadInteraction) : hadInteraction(field);\r\n            if (touchedByUser) {\r\n                return;\r\n            }\r\n            const newValue = getFromPath(initialValues.value, fieldPath);\r\n            setInPath(formValues, fieldPath, newValue);\r\n        });\r\n    }\r\n    if (isRef(providedValues)) {\r\n        watch(providedValues, value => {\r\n            setInitialValues(value, true);\r\n        }, {\r\n            deep: true,\r\n        });\r\n    }\r\n    provide(FormInitialValuesKey, computedInitials);\r\n    return {\r\n        readonlyInitialValues: computedInitials,\r\n        initialValues,\r\n        setInitialValues,\r\n    };\r\n}\r\nfunction useErrorBag(initialErrors) {\r\n    const errorBag = ref({});\r\n    function normalizeErrorItem(message) {\r\n        return Array.isArray(message) ? message : message ? [message] : [];\r\n    }\r\n    /**\r\n     * Manually sets an error message on a specific field\r\n     */\r\n    function setFieldErrorBag(field, message) {\r\n        if (!message) {\r\n            delete errorBag.value[field];\r\n            return;\r\n        }\r\n        errorBag.value[field] = normalizeErrorItem(message);\r\n    }\r\n    /**\r\n     * Sets errors for the fields specified in the object\r\n     */\r\n    function setErrorBag(fields) {\r\n        errorBag.value = keysOf(fields).reduce((acc, key) => {\r\n            const message = fields[key];\r\n            if (message) {\r\n                acc[key] = normalizeErrorItem(message);\r\n            }\r\n            return acc;\r\n        }, {});\r\n    }\r\n    if (initialErrors) {\r\n        setErrorBag(initialErrors);\r\n    }\r\n    return {\r\n        errorBag,\r\n        setErrorBag,\r\n        setFieldErrorBag,\r\n    };\r\n}\n\nconst Form = defineComponent({\r\n    name: 'Form',\r\n    inheritAttrs: false,\r\n    props: {\r\n        as: {\r\n            type: String,\r\n            default: 'form',\r\n        },\r\n        validationSchema: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        initialValues: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        initialErrors: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        initialTouched: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        validateOnMount: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        onSubmit: {\r\n            type: Function,\r\n            default: undefined,\r\n        },\r\n    },\r\n    setup(props, ctx) {\r\n        const initialValues = toRef(props, 'initialValues');\r\n        const validationSchema = toRef(props, 'validationSchema');\r\n        const { errors, values, meta, isSubmitting, submitCount, validate, validateField, handleReset, resetForm, handleSubmit, submitForm, setErrors, setFieldError, setFieldValue, setValues, setFieldTouched, setTouched, } = useForm({\r\n            validationSchema: validationSchema.value ? validationSchema : undefined,\r\n            initialValues,\r\n            initialErrors: props.initialErrors,\r\n            initialTouched: props.initialTouched,\r\n            validateOnMount: props.validateOnMount,\r\n        });\r\n        const onSubmit = props.onSubmit ? handleSubmit(props.onSubmit) : submitForm;\r\n        function handleFormReset(e) {\r\n            if (isEvent(e)) {\r\n                // Prevent default form reset behavior\r\n                e.preventDefault();\r\n            }\r\n            handleReset();\r\n            if (typeof ctx.attrs.onReset === 'function') {\r\n                ctx.attrs.onReset();\r\n            }\r\n        }\r\n        function handleScopedSlotSubmit(evt, onSubmit) {\r\n            const onSuccess = typeof evt === 'function' && !onSubmit ? evt : onSubmit;\r\n            return handleSubmit(onSuccess)(evt);\r\n        }\r\n        function slotProps() {\r\n            return {\r\n                meta: meta.value,\r\n                errors: errors.value,\r\n                values: values,\r\n                isSubmitting: isSubmitting.value,\r\n                submitCount: submitCount.value,\r\n                validate,\r\n                validateField,\r\n                handleSubmit: handleScopedSlotSubmit,\r\n                handleReset,\r\n                submitForm,\r\n                setErrors,\r\n                setFieldError,\r\n                setFieldValue,\r\n                setValues,\r\n                setFieldTouched,\r\n                setTouched,\r\n                resetForm,\r\n            };\r\n        }\r\n        // expose these functions and methods as part of public API\r\n        ctx.expose({\r\n            setFieldError,\r\n            setErrors,\r\n            setFieldValue,\r\n            setValues,\r\n            setFieldTouched,\r\n            setTouched,\r\n            resetForm,\r\n            validate,\r\n            validateField,\r\n        });\r\n        return function renderForm() {\r\n            // avoid resolving the form component as itself\r\n            const tag = props.as === 'form' ? props.as : resolveDynamicComponent(props.as);\r\n            const children = normalizeChildren(tag, ctx, slotProps);\r\n            if (!props.as) {\r\n                return children;\r\n            }\r\n            // Attributes to add on a native `form` tag\r\n            const formAttrs = props.as === 'form'\r\n                ? {\r\n                    // Disables native validation as vee-validate will handle it.\r\n                    novalidate: true,\r\n                }\r\n                : {};\r\n            return h(tag, Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), { onSubmit, onReset: handleFormReset }), children);\r\n        };\r\n    },\r\n});\n\nconst ErrorMessage = defineComponent({\r\n    name: 'ErrorMessage',\r\n    props: {\r\n        as: {\r\n            type: String,\r\n            default: undefined,\r\n        },\r\n        name: {\r\n            type: String,\r\n            required: true,\r\n        },\r\n    },\r\n    setup(props, ctx) {\r\n        const errors = inject(FormErrorsKey, undefined);\r\n        const message = computed(() => {\r\n            return errors === null || errors === void 0 ? void 0 : errors.value[props.name];\r\n        });\r\n        function slotProps() {\r\n            return {\r\n                message: message.value,\r\n            };\r\n        }\r\n        return () => {\r\n            // Renders nothing if there are no messages\r\n            if (!message.value) {\r\n                return undefined;\r\n            }\r\n            const tag = (props.as ? resolveDynamicComponent(props.as) : props.as);\r\n            const children = normalizeChildren(tag, ctx, slotProps);\r\n            const attrs = Object.assign({ role: 'alert' }, ctx.attrs);\r\n            // If no tag was specified and there are children\r\n            // render the slot as is without wrapping it\r\n            if (!tag && (Array.isArray(children) || !children) && (children === null || children === void 0 ? void 0 : children.length)) {\r\n                return children;\r\n            }\r\n            // If no children in slot\r\n            // render whatever specified and fallback to a <span> with the message in it's contents\r\n            if ((Array.isArray(children) || !children) && !(children === null || children === void 0 ? void 0 : children.length)) {\r\n                return h(tag || 'span', attrs, message.value);\r\n            }\r\n            return h(tag, attrs, children);\r\n        };\r\n    },\r\n});\n\nfunction useResetForm() {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return function resetForm(state) {\r\n        if (!form) {\r\n            return;\r\n        }\r\n        return form.resetForm(state);\r\n    };\r\n}\n\n/**\r\n * If a field is dirty or not\r\n */\r\nfunction useIsFieldDirty(path) {\r\n    const form = injectWithSelf(FormContextKey);\r\n    let field = path ? undefined : inject(FieldContextKey);\r\n    return computed(() => {\r\n        if (path) {\r\n            field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsById.value[unref(path)]);\r\n        }\r\n        if (!field) {\r\n            warn(`field with name ${unref(path)} was not found`);\r\n            return false;\r\n        }\r\n        return field.meta.dirty;\r\n    });\r\n}\n\n/**\r\n * If a field is touched or not\r\n */\r\nfunction useIsFieldTouched(path) {\r\n    const form = injectWithSelf(FormContextKey);\r\n    let field = path ? undefined : inject(FieldContextKey);\r\n    return computed(() => {\r\n        if (path) {\r\n            field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsById.value[unref(path)]);\r\n        }\r\n        if (!field) {\r\n            warn(`field with name ${unref(path)} was not found`);\r\n            return false;\r\n        }\r\n        return field.meta.touched;\r\n    });\r\n}\n\n/**\r\n * If a field is validated and is valid\r\n */\r\nfunction useIsFieldValid(path) {\r\n    const form = injectWithSelf(FormContextKey);\r\n    let field = path ? undefined : inject(FieldContextKey);\r\n    return computed(() => {\r\n        if (path) {\r\n            field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsById.value[unref(path)]);\r\n        }\r\n        if (!field) {\r\n            warn(`field with name ${unref(path)} was not found`);\r\n            return false;\r\n        }\r\n        return field.meta.valid;\r\n    });\r\n}\n\n/**\r\n * If the form is submitting or not\r\n */\r\nfunction useIsSubmitting() {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.isSubmitting.value) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n}\n\n/**\r\n * Validates a single field\r\n */\r\nfunction useValidateField(path) {\r\n    const form = injectWithSelf(FormContextKey);\r\n    let field = path ? undefined : inject(FieldContextKey);\r\n    return function validateField() {\r\n        if (path) {\r\n            field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsById.value[unref(path)]);\r\n        }\r\n        if (!field) {\r\n            warn(`field with name ${unref(path)} was not found`);\r\n            return Promise.resolve({\r\n                errors: [],\r\n                valid: true,\r\n            });\r\n        }\r\n        return field.validate();\r\n    };\r\n}\n\n/**\r\n * If the form is dirty or not\r\n */\r\nfunction useIsFormDirty() {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.dirty) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n}\n\n/**\r\n * If the form is touched or not\r\n */\r\nfunction useIsFormTouched() {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.touched) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n}\n\n/**\r\n * If the form has been validated and is valid\r\n */\r\nfunction useIsFormValid() {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.valid) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n}\n\n/**\r\n * Validate multiple fields\r\n */\r\nfunction useValidateForm() {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return function validateField() {\r\n        if (!form) {\r\n            return Promise.resolve({ results: {}, errors: {}, valid: true });\r\n        }\r\n        return form.validate();\r\n    };\r\n}\n\n/**\r\n * The number of form's submission count\r\n */\r\nfunction useSubmitCount() {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.submitCount.value) !== null && _a !== void 0 ? _a : 0;\r\n    });\r\n}\n\n/**\r\n * Gives access to a field's current value\r\n */\r\nfunction useFieldValue(path) {\r\n    const form = injectWithSelf(FormContextKey);\r\n    // We don't want to use self injected context as it doesn't make sense\r\n    const field = path ? undefined : inject(FieldContextKey);\r\n    return computed(() => {\r\n        var _a;\r\n        if (path) {\r\n            return getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(path));\r\n        }\r\n        return (_a = field === null || field === void 0 ? void 0 : field.value) === null || _a === void 0 ? void 0 : _a.value;\r\n    });\r\n}\n\n/**\r\n * Gives access to a form's values\r\n */\r\nfunction useFormValues() {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        return (form === null || form === void 0 ? void 0 : form.values) || {};\r\n    });\r\n}\n\n/**\r\n * Gives access to all form errors\r\n */\r\nfunction useFormErrors() {\r\n    const errors = injectWithSelf(FormErrorsKey);\r\n    if (!errors) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return errors || computed(() => ({}));\r\n}\n\n/**\r\n * Gives access to a single field error\r\n */\r\nfunction useFieldError(path) {\r\n    const errors = injectWithSelf(FormErrorsKey);\r\n    // We don't want to use self injected context as it doesn't make sense\r\n    const field = path ? undefined : inject(FieldContextKey);\r\n    return computed(() => {\r\n        var _a;\r\n        if (path) {\r\n            return (_a = errors === null || errors === void 0 ? void 0 : errors.value) === null || _a === void 0 ? void 0 : _a[unref(path)];\r\n        }\r\n        return field === null || field === void 0 ? void 0 : field.errorMessage.value;\r\n    });\r\n}\n\nfunction useSubmitForm(cb) {\r\n    const form = injectWithSelf(FormContextKey);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    const onSubmit = form ? form.handleSubmit(cb) : undefined;\r\n    return function submitForm(e) {\r\n        if (!onSubmit) {\r\n            return;\r\n        }\r\n        return onSubmit(e);\r\n    };\r\n}\n\nexport { ErrorMessage, Field, FieldContextKey, Form, FormContextKey, configure, defineRule, useField, useFieldError, useFieldValue, useForm, useFormErrors, useFormValues, useIsFieldDirty, useIsFieldTouched, useIsFieldValid, useIsFormDirty, useIsFormTouched, useIsFormValid, useIsSubmitting, useResetForm, useSubmitCount, useSubmitForm, useValidateField, useValidateForm, validate };\n"],"sourceRoot":""}